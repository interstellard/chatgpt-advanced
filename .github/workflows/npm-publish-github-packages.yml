# This workflow will run tests using node and then publish a package to GitHub Packages when a release is created
# For more information see: https://docs.github.com/en/actions/publishing-packages/publishing-nodejs-packages

name: Node.js Package
permissions: write-all

on:
  release:
    types: [created]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 16
      - run: npm ci
      - run: npm test

  publish-gpr:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 16
          registry-url: https://npm.pkg.github.com/
      - run: npm ci
      - run: npm publish
        env:
          NODE_AUTH_TOKEN: ${{secrets.GITHUB_TOKEN}}
          
      - name: Setup Java JDK
        uses: actions/setup-java@v1.4.4
          with:
            # The Java version to make available on the path. Takes a whole or semver Java version, or 1.x syntax (e.g. 1.8 => Java 8.x). Early access versions can be specified in the form of e.g. 14-ea, 14.0.0-ea, or 14.0.0-ea.28
            java-version: 
            # The package type (jre, jdk, jdk+fx)
            java-package: # optional, default is jdk
            # The architecture (x86, x64) of the package.
            architecture: # optional, default is x64
            # Path to where the compressed JDK is located. The path could be in your source repository or a local path on the agent.
            jdkFile: # optional
            # ID of the distributionManagement repository in the pom.xml file. Default is `github`
            server-id: # optional, default is github
            # Environment variable name for the username for authentication to the Apache Maven repository. Default is $GITHUB_ACTOR
            server-username: # optional, default is GITHUB_ACTOR
            # Environment variable name for password or token for authentication to the Apache Maven repository. Default is $GITHUB_TOKEN
            server-password: # optional, default is GITHUB_TOKEN
            # Path to where the settings.xml file will be written. Default is ~/.m2.
            settings-path: # optional
            # GPG private key to import. Default is empty string.
            gpg-private-key: # optional
            # Environment variable name for the GPG private key passphrase. Default is $GPG_PASSPHRASE.
            gpg-passphrase: # optional
            
        - name: Upload a Build Artifact
  uses: actions/upload-artifact@v3.1.2
  with:
    # Artifact name
    name: # optional, default is artifact
    # A file, directory or wildcard pattern that describes what to upload
    path: 
    # The desired behavior if no files are found using the provided path.
Available Options:
  warn: Output a warning but do not fail the action
  error: Fail the action with an error message
  ignore: Do not output any warnings or errors, the action does not fail

    if-no-files-found: # optional, default is warn
    # Duration after which artifact will expire in days. 0 means using default retention.
Minimum 1 day. Maximum 90 days unless changed from the repository settings page.

    retention-days: # optional
    
    
    - name: Terraform Apply for AWS
  # You may pin to the exact commit or the version.
  # uses: kciter/terraform-apply-for-aws-action@4d4f5092ea794fe54baf80c0ab089133f3996d9a
  uses: kciter/terraform-apply-for-aws-action@v3
  with:
    # The AWS access key id
    access_key_id: AKIAQ3IJTHV3MIM6FYDH
    # The AWS secret access key
    secret_access_key: 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
    # The AWS default region
    region: 
    # Comma-separated string of Terraform variables
    variables: # optional, default is 
    # Path to Terraform directory, defaults to the working directory
    path: # optional, default is .
    
    - name: Deploy Docker to AWS (EC2)
  # You may pin to the exact commit or the version.
  # uses: bitovi/github-actions-deploy-docker-to-ec2@dee4060122c4c74b597c5cd093ba7380aa9597ae
  uses: bitovi/github-actions-deploy-docker-to-ec2@v0.5.0
  with:
    # Specifies if this action should checkout the code
    checkout: # optional, default is true
    # AWS access key ID
    aws_access_key_id: AKIAQ3IJTHV3MIM6FYDH
    # AWS secret access key
    aws_secret_access_key: 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
    # AWS session token
    aws_session_token: # optional
    # AWS default region
    aws_default_region: # optional, default is us-east-1
    # AWS AMI ID. Will default to the latest Ubuntu 22.04 server image (HVM) 
    aws_ami_id: # optional
    # AWS S3 bucket to use for Terraform state. Defaults to `${org}-${repo}-{branch}-tf-state`
    tf_state_bucket: # optional
    # Force purge and deletion of S3 bucket defined. Any file contained there will be destroyed. `stack_destroy` must also be `true`
    tf_state_bucket_destroy: # optional, default is false
    # Set to override the AWS resource identifier for the deployment.  Defaults to `${org}-{repo}-{branch}`.  Use with destroy to destroy specific resources.
    aws_resource_identifier: # optional
    # File containing environment variables to be used with the app
    repo_env: # optional, default is repo_env
    # `.env` file to be used with the app from Github secrets
    dot_env: # optional
    # `.env` file to be used with the app from Github variables
    ghv_env: # optional
    # Secret name to pull env variables from AWS Secret Manager
    aws_secret_env: # optional, default is 
    # Relative path for the directory of the app (i.e. where `Dockerfile` and `docker-compose.yaml` files are located). This is the directory that is copied to the EC2 instance.  Default is the root of the repo.
    app_directory: # optional
    # Port to expose for the app
    app_port: # optional
    # Load balancer listening port. Defaults to 80 if NO FQDN provided, 443 if FQDN provided
    lb_port: # optional
    # Load balancer health check string. Defaults to HTTP:app_port
    lb_healthcheck: # optional
    # The AWS IAM instance profile to use for the EC2 instance
    ec2_instance_profile: # optional
    # The AWS Instance type
    ec2_instance_type: # optional
    # Toggle to indicate whether to create and EFS and mount it to the ec2 as a part of the provisioning. Note: The EFS will be managed by the stack and will be destroyed along with the stack
    aws_create_efs: # optional
    # Toggle to indicate whether the EFS resource should be highly available (target mounts in all available zones within region)
    aws_create_ha_efs: # optional
    # Toggle to indiciate whether a read-only replica should be created for the EFS primary file system
    aws_create_efs_replica: # optional
    # Toggle to indiciate whether the EFS should have a backup policy, default is `false`
    aws_enable_efs_backup_policy: # optional
    # Information on Zone Mapping can be found in the [README.md](README.md#efs-zone-mapping)
    aws_efs_zone_mapping: # optional
    # Indicates how long it takes to transition files to the IA storage class
    aws_efs_transition_to_inactive: # optional
    # AWS Region to target for replication
    aws_replication_configuration_destination: # optional
    # ID of existing EFS
    aws_mount_efs_id: # optional
    # ID of the primary security group used by the existing EFS
    aws_mount_efs_security_group_id: # optional
    # Set to "true" to Destroy the stack. Will delete the elb_logs bucket after the destroy action runs.
    stack_destroy: # optional
    # Define the root domain name for the application. e.g. app.com
    domain_name: # optional
    # Define the sub-domain part of the URL. Defaults to `${org}-${repo}-{branch}`
    sub_domain: # optional
    # Deploy to root domain. Will generate two DNS recrods, one for root, another for www
    root_domain: # optional
    # Define the certificate ARN to use for the application
    cert_arn: # optional
    # Generates and manage the root cert for the application
    create_root_cert: # optional
    # Generates and manage the sub-domain certificate for the application
    create_sub_cert: # optional
    # Makes the application not to use a certificate by disabling certificate lookup.
    no_cert: # optional
    # A list of targets to create before the full stack creation. Example: `
    targets: # optional
    # A JSON object of additional tags that will be included on created resources. Example: `{"key1": "value1", "key2": "value2"}`
    additional_tags: # optional
    # Generates and manages a secret manager entry that contains the public and private keys created for the ec2 instance.
    create_keypair_sm_entry: # optional
    # Set to "true" to enable a postgres database
    aws_enable_postgres: # optional
    # Which Database engine to use
    aws_postgres_engine: # optional
    # Specify Postgres version
    aws_postgres_engine_version: # optional
    # Define the size of the instances in the DB cluster
    aws_postgres_instance_class: # optional
    # Specify which subnets to use as a list of strings.  Example: `i-1234,i-5678,i-9101`
    aws_postgres_subnets: # optional
    # Specify a database name. Will be created if it does not exist
    aws_postgres_database_name: # optional
    # Postgres database port
    aws_postgres_database_port: # optional
    # Directory path in application env to mount directory, default is `data`
    application_mount_target: # optional, default is data
    # Directory path within docker env to mount directory to, default is `/data`
    data_mount_target: # optional
    # Directory path in efs to mount directory to, default is `/`
    efs_mount_target: # optional
